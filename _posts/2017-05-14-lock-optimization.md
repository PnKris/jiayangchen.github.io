---
layout: post
title: "深入理解java虚拟机 —— Java 锁优化"
subtitle: ""
date: 2017-05-14
author: "ChenJY"
header-img: "img/java.jpg"
catalog: true
tags: 
    - 深入理解Java虚拟机
---

高效并发是JDK1.5到JDK1.6的一个重要改进，Hotspot虚拟机开发团队在这个版本上花了大量精力去实现各种锁优化技术，如自旋适应锁、锁消除、锁粗化、轻量级锁和偏向锁，这些技术都是为了在线程之间更高效的共享数据以及解决竞争的问题。

### 自旋锁与自适应自旋
许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，我们可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。

优点是如果锁被占用时间很短，自旋等待的效果就会非常好；反之如果锁被占用时间很长，自旋线程只会浪费处理器资源而不做任何有效的工作。因此自旋必须有一定的限度，如果超过限度仍然没有获得锁，就应当使用传统方式挂起线程，自旋次数默认是10。

JDK1.6中引入自旋锁并不意味着自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果同一个锁对象上，自旋等待刚刚成功获得过锁，那么这次有可能继续成功，进而它将允许自旋等待持续更长的时间；反之如果很少成功获得，那么这个锁可能就会省略掉自旋过程。

### 锁消除
对于一些要求同步，但是检测到不可能存在共享数据竞争的锁进行消除，主要依赖于逃逸分析的数据支持实现这个功能

### 锁粗化
如果一系列连续操作对同一个对象反复加锁解锁，例如加锁操作出现在循环体中，那么这会导致不必要的性能损耗。如果虚拟机探测到这种情况，将会把锁的范围扩大到整个操作序列的外部，这样只需要加一次锁就够了。

### 轻量级锁
使用CAS更新对象的Mark World

### 偏向锁