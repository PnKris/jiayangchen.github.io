---
layout: post
title: "深入理解java虚拟机 —— Java GC算法"
subtitle: "填坑进行时..."
date: 2017-07-12
author: "ChenJY"
header-img: "img/drive.jpg"
catalog: true
tags: 
    - 深入理解Java虚拟机
---
### 标记清除
第一步标记所有需要回收的对象，然后进行回收。不足一是效率问题，标记和清除两个过程的效率都不高；二是标记清除之后会产生大量不连续碎片，后续分配大对象时会无法找到足够的连续内存而不得不触发GC

### 复制算法
为解决效率问题，将内存容量划分为大小相等的两块，每次只使用其中的一块，当这块用完了，将其中存活的对象复制到另外一块，使得每次都只对半块进行回收，不会担心碎片问题。但代价是可用的内存变为原先的一半。商业虚拟机采用这种方法回收新生代，但并不是按照1:1来划分两快内存，Hotspot按照8:1划分。

### 标记整理
复制算法在对象存活率较高时就需要进行较多的复制，效率会很低。根据老年代的特点，提出了标记整理算法，先进性标记清除，然后让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。

### 分代收集
#### Java 堆内存
我们有必要了解堆内存在JVM内存模型的角色。在运行时，Java的实例被存放在堆内存区域。当一个对象不再被引用时，满足条件就会从堆内存移除。在垃圾回收进程中，这些对象将会从堆内存移除并且内存空间被回收。堆内存以下三个主要区域：

新生代（Young Generation）
Eden空间（Eden space，任何实例都通过Eden空间进入运行时内存区域）
S0 Survivor空间（S0 Survivor space，存在时间长的实例将会从Eden空间移动到S0 Survivor空间）
S1 Survivor空间 （存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间）
老年代（Old Generation）实例将从S1提升到Tenured（终身代）
永久代（Permanent Generation）包含类、方法等细节的元信息

根据对象的存活周期不同将内存划分成不同的快，一般有新生代和老年代，新生代使用复制，老年代使用标记整理