---
layout: post
title: "计算机网络 —— tcp连接和断开"
subtitle: "三次握手，四次挥手详解"
date: 2017-07-28
author: "ChenJY"
header-img: "img/java.jpg"
catalog: true
tags: 
    - 网络
---

### 三次握手
![image](http://blog.chinaunix.net/attachment/201310/1/28263175_1380611229SPU6.png)
B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求，然后服务器进行就处于LISTEN状态，等待客户的连接请求。

A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出连接请求报文段，这时首部中的同部位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但要消耗掉一个序号，此时，客户端进入 SYN-SENT（同步已发送）状态。

B收到连接请求报文之后，若同意连接，则向A发送确认，在确认报文段中应把SYN和ACK位都置为1，确认序号是ack=x+1，同时也要为自己选择一个初始序号seq= y。请注意，这个报文段也不能携带数据，但同样要消耗一个序号，这时，TCP服务器进程进入SYN-REVD状态。

TCP客户进程收到B的确认之后，还要向B给出确认。确认报文段的ACK置为1，确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍然是seq=x+1。这时TCP连接已经建立，A进入ESTABLISHED状态。当B收到A的确认之后，也进入ESTABLISHED状态。

上述称为三次握手

### 为什么要三次？
采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。

### 四次挥手
![image](http://blog.chinaunix.net/attachment/201310/1/28263175_13806112555gGu.png)
四次挥手过程稍微复杂一些，还是结合双方状态来阐述一下。
数据传输结束之后，通信双方都可以释放连接，现在A和B均处于释放报文阶段，并停止再发送数据，主动关闭TCP连接。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。

A把释放报文段首部的FIN置为1，其序号为seq=u，他等于前面一传送过的数据的最后一个字节的序号加1。这时A进入FIN-WAIT1状态，等到B的确认。请注意，TCP规定，FIN报文段即使不携带数据，他也消耗掉一个序号。

B收到连接释放报文段之后，即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v， 等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT状态。TCP服务器进程这时候通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态（half-close），即A已经没有数据要发送了，但B若发送数据，A仍需要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能持续一段时间。

A收到来自B的确认后，就进入FIN-WAIT2状态 ，等待B发出的连接释放报文段。

若B已经没有要向A发送的数据了，其应用进程就通知TCP释放链接，这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w（因为半关闭状态期间可能B还发送了一些数据）。B还必须重复上次已发送过的确认号ack=u+1。这时B就进入了LAST-ACK（最后确认状态）状态，等待A的确认。

A在收到B的连接释放报文段之后，必须对此发出确认。在确认报文段中把ACK置为1，确认号ack=w+1，而自己的序列号是seq=u+1（因为根据TCP标准，前面发送过的FIN报文段要消耗一个序列号）。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放，必须经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。时间MSL叫做最长报文段寿命，RPC793建议设置为2分钟，但实际工程中可根据实际情况调整。因此，从A进入到TIME-WAIT状态后，要经过四分钟才能进入CLOSED状态，才能开始建立下一个连接。当A撤销控制传输快TCB后，就结束了这次的TCP连接。

### 为什么A在TIME-WAIT之后要等待2MSL呢？
这里有两个理由：
1. 保证A发送的最后一个ACK报文能到达B。这个ACK报文很有可能丢失，因而使得处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后AB均能进入正常的CLOSED状态。

2. 防止上一节提到的 “已失效的连接请求报文段” 出现在本链接中，A在发送完最后一个ACK报文后，再经过时间2MSL，就可以使得本链接持续时间内所产生的所有报文段都从网络中消失。这样就可以使得下一个新连接中不会出现这种旧的连接请求报文段。

### 保活计时器
客户已主动与服务器建立TCP连接，但后来客户端出现故障，服务器收不到客户端的数据，因此服务器不能白白等下去，服务器每收到客户端的消息就重新设置保活计时器，通常是两小时，若两小时没再收到客户端发来的数据，服务器就发送探测报文段，以后每隔75分钟发送一次，若一连发送十个探测报文段仍然没有客户端的响应，服务器就认为客户端出现了故障，接着就关闭这个链接。

### TCP的有限状态机
![image](http://www.cnitblog.com/images/cnitblog_com/wildon/544465b00200001s.png)

### 参考资料
* 《计算机网络 第五版》 谢希仁著

